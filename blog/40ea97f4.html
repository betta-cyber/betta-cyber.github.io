<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>Linux 文件监控 - B</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=betta-cyber, game, betta, shokill>
  
    <meta name="description" content="betta">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="B" type="application/atom+xml">
  

  

  

  <!-- <link rel="stylesheet" href="../css/style.css"> -->
  
<link rel="stylesheet" href="/css/style.css">

  <script type='text/javascript' id='clustrmaps' src='//cdn.clustrmaps.com/map_v2.js?cl=ffffff&w=0&t=n&d=b9cDq33TdEsfGb_DpY--uB2pjskzQ8TK9LaE3yuIYzE&co=ffffff&cmo=ffffff&cmn=ffffff&ct=ffffff'></script>
<meta name="generator" content="Hexo 5.4.1"></head>

  <body>
    <div class="container">
      <header class="header">
  <!-- <div class="blog-title">
    <a href="/" class="logo">B</a>
    <div class="subtitle"></div>
  </div> -->
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link " >Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/blog" class="menu-item-link active" >Blog</a>
        </li>
      
        <li class="menu-item">
          <a href="/ebook" class="menu-item-link " >Ebook</a>
        </li>
      
        <li class="menu-item">
          <a href="/music" class="menu-item-link " >Music</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link " >About</a>
        </li>
      
    </ul>
  </nav>
</header>

<article class="post">
  <div class="post-title">
    <h1 class="article-title">Linux 文件监控</h1>
  </div>
  <div class="post-content">
    <h1 id="一、方式"><a href="#一、方式" class="headerlink" title="一、方式"></a>一、方式</h1><ol>
<li>stat<br>stat是一个在Linux系统上查看文件或文件系统状态的工具。用获取文件的最近访问时间、修改时间、权限等信息，并编写脚本以定期运行该命令以监控文件状态的变化。</li>
<li>sysdig<br>  sysdig 是一个超级系统工具，可用来捕获系统状态信息。提供命令行接口以及强大的交互界面。支持各种 IO 活动：进程、文件、网络连接等。</li>
<li>inotifywait<br>需要安装inotify-tools。</li>
<li>inotify&#x2F;fanotify<br>Linux 系统调用。</li>
</ol>
<h1 id="二、inotify简介"><a href="#二、inotify简介" class="headerlink" title="二、inotify简介"></a>二、inotify简介</h1><h2 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h2><p>inotify是Linux内核提供的一种文件系统监控机制。它通过在文件系统的目录上设置监视器来跟踪文件和目录的变化。当监视的文件或目录发生指定的事件时，内核会生成相应的事件通知。 从Linux内核2.6.13版本开始支持inotify。</p>
<h2 id="2-2-主要特点"><a href="#2-2-主要特点" class="headerlink" title="2.2 主要特点"></a>2.2 主要特点</h2><p>inotify具有以下主要特点：</p>
<ul>
<li>支持多种事件类型：inotify支持多种事件类型，比如文件访问、修改、属性变化、打开、关闭等，应用程序可以根据需要选择监视的事件类型。</li>
<li>精确性：inotify可以精确地追踪指定目录或文件是移入，还是移出，关闭前是否写入等操作。</li>
<li>灵活性：应用程序可以根据具体需求动态添加和移除监视器，可以对不同的文件和目录设置不同的监视器。</li>
<li>高效性：inotify使用内核回调机制，避免了不必要的轮询操作。<br>这些特点使得inotify成为在Linux系统上实现文件系统监控的重要工具，广泛应用于文件同步、日志监控、自动化部署等领域。</li>
</ul>
<h2 id="2-3-工作方式"><a href="#2-3-工作方式" class="headerlink" title="2.3 工作方式"></a>2.3 工作方式</h2><p>接口说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/inotify.h&gt;</span><br><span class="line"></span><br><span class="line">int inotify_init(void);</span><br><span class="line">int inotify_init1(int flags);</span><br><span class="line">/* </span><br><span class="line"> * flags：初始化标志，用于指定inotify实例的行为选项。</span><br><span class="line"> * 可以使用以下标志进行设置：</span><br><span class="line"> * IN_CLOEXEC：设置此标志后，在执行exec时会关闭inotify文件描述符。</span><br><span class="line"> * IN_NONBLOCK：设置此标志后，inotify文件描述符将以非阻塞模式打开。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int inotify_add_watch(int fd, const char *pathname, uint32_t mask);</span><br><span class="line">/* fd： inotify实例的文件描述符。</span><br><span class="line"> * pathname：监视的文件或目录的路径。</span><br><span class="line"> * mask：监视的事件类型，可以是单个事件类型或多个事件类型的组合。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">struct inotify_event</span><br><span class="line">&#123;</span><br><span class="line">  int wd;  //监控事件的文件描述符（watch descriptor）。</span><br><span class="line">  uint32_t mask;  //表示事件的掩码，指定了哪些事件发生时会触发 inotify 通知。</span><br><span class="line">  uint32_t cookie;  //用于关联相关的事件。</span><br><span class="line">  uint32_t len;   //文件或目录名的长度。</span><br><span class="line">  char name __flexarr;  //文件或目录的名称。__flexarr定义为[0]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用流程：</p>
<ol>
<li>创建inotify实例：应用程序通过调用inotify_init()或inotify_init1()函数创建一个inotify实例，返回一个文件描述符。</li>
<li>添加监视器：应用程序使用inotify_add_watch()函数将要监视的文件或目录添加到inotify实例中，并指定要监视的事件类型。</li>
<li>读取事件：应用程序使用read()函数读取inotify实例的文件描述符，以获取事件通知。</li>
<li>处理事件：应用程序读取到的事件通知，根据事件的类型执行相应的操作。</li>
</ol>
<p>常用14事件：</p>
<ul>
<li>IN_ACCESS：文件被访问（读取）。</li>
<li>IN_MODIFY：文件被修改。</li>
<li>IN_ATTRIB：文件属性发生变化，如权限、所有权或时间戳。</li>
<li>IN_CLOSE_WRITE：文件被关闭（写入完成）。</li>
<li>IN_CLOSE_NOWRITE：文件被关闭，但没有写入操作。</li>
<li>IN_OPEN：文件被打开。</li>
<li>IN_MOVED_FROM：文件被移出监控目录。</li>
<li>IN_MOVED_TO：文件被移入监控目录。</li>
<li>IN_CREATE：文件或目录被创建。</li>
<li>IN_DELETE：文件或目录被删除。</li>
<li>IN_DELETE_SELF：监控的文件或目录本身被删除。</li>
<li>IN_MOVE_SELF：监控的文件或目录本身被移动。</li>
<li>IN_UNMOUNT：文件系统被卸载。</li>
<li>IN_ONESHOT：只会触发一次事件通知<ol>
<li>事件标志是用于指定一个 inotify 监听只会触发一次事件通知。这对于某些场景很有用，一旦触发了一次事件通知，不再需要继续监听的情况下，可以节省资源并简化代码逻辑。</li>
<li>需要注意的是，IN_ONESHOT 事件标志仅适用于单个事件。即使注册时设置了 IN_ONESHOT 标志，如果同一个文件或目录上发生多个事件，每个事件都会触发一个事件通知。只有当前注册的事件完成后，才会取消监听该。</li>
<li>此外，需要注意不同版本的 Linux 内核对 IN_ONESHOT 的支持可能会有所差异，请确保在目标系统上的内核版本中支持该标志。</li>
</ol>
</li>
</ul>
<p>实例演示：<br>统计写falsh次数，防止高频度写falsh引发坏块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/inotify.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_EVENTS 1024</span><br><span class="line">#define EVENT_SIZE  (sizeof(struct inotify_event))</span><br><span class="line">#define BUFFER_SIZE (MAX_EVENTS * (sizeof(struct inotify_event) + 16))</span><br><span class="line"></span><br><span class="line">int main(int argc ,char* argv[]) &#123;</span><br><span class="line">    int fd, wd;</span><br><span class="line">    struct inotify_event *event;</span><br><span class="line">    char buffer[BUFFER_SIZE];</span><br><span class="line">    ssize_t len;</span><br><span class="line">    char * path = argv[1];</span><br><span class="line">    long long num = 0;</span><br><span class="line"></span><br><span class="line">    // 创建inotify实例</span><br><span class="line">    fd = inotify_init();</span><br><span class="line">    if (fd == -1) &#123;</span><br><span class="line">        perror(&quot;inotify_init&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加监控的文件路径，并指定要监控的事件</span><br><span class="line">    wd = inotify_add_watch(fd, path, IN_MODIFY | IN_OPEN);</span><br><span class="line">    if (wd == -1) &#123;</span><br><span class="line">        perror(&quot;inotify_add_watch&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取inotify事件</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        len = read(fd, buffer, BUFFER_SIZE);</span><br><span class="line">        if (len == -1) &#123;</span><br><span class="line">            perror(&quot;read&quot;);</span><br><span class="line">            exit(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 解析inotify事件</span><br><span class="line">        event = (struct inotify_event *) buffer;</span><br><span class="line">        while (len &gt; 0) &#123;</span><br><span class="line">            if (event-&gt;mask &amp; IN_MODIFY) &#123;</span><br><span class="line">                printf(&quot;File modified: %s num:%lld\n&quot;, event-&gt;name, num);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (event-&gt;mask &amp; IN_OPEN) &#123;</span><br><span class="line">                printf(&quot;File opened: %s\n&quot;, event-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 指向下一个事件</span><br><span class="line">            event = (struct inotify_event *) ((char *) event + EVENT_SIZE + event-&gt;len);</span><br><span class="line">            len -= EVENT_SIZE + event-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 关闭inotify实例</span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实现了监控打开、修改两种种事件监控，当触发对应事件，会打印输出被操作的目录或文件名称，同时会输出修改文件次数。</p>
<h2 id="2-4-开源项目中的应用"><a href="#2-4-开源项目中的应用" class="headerlink" title="2.4 开源项目中的应用"></a>2.4 开源项目中的应用</h2><ul>
<li>文件自动同步的功能：使用inotify来监控文件的变化，通过rsync同步。<ul>
<li>inotify-tools：一组命令行工具，包括inotifywait和inotifywatch，用于监控文件系统事件。</li>
<li>inoticoming：是一个基于 inotify 机制的工具，用于在 Linux 系统上监视文件系统事件并执行相应的命令。</li>
</ul>
</li>
<li>Systemd：Linux系统初始化和管理守护进程，使用inotify来监控系统日志文件的变化。</li>
<li>Android系统WiFi管理器：通过inotify监控wpa_supplicant.conf文件变化，读取新的配置信息。</li>
</ul>
<h3 id="2-5-注意事项"><a href="#2-5-注意事项" class="headerlink" title="2.5 注意事项"></a>2.5 注意事项</h3><ol>
<li>文件描述符限制：Linux 系统对打开的文件描述符数量有限制，因此在监控大量文件或目录时，可能会超出文件描述符限制。可以使用 ulimit  命令或调整系统配置文件来增加文件描述符数量限制。<br>文件描述符限制对于使用 inotify 监控文件系统特别重要。当使用 inotify 监控大量的文件或目录时，每个监控项都需要占用一个文件描述符。如果超过了进程的文件描述符限制，就无法继续创建新的监控项。</li>
<li>内核限制：Linux 内核也对 inotify 实例数量和队列大小有限制。可以通过修改 &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify 目录下的文件来调整这些限制。<br>max_user_instances 表示每个用户可创建的 inotify 实例数量的最大限制。每个实例可以监视多个文件或目录。一般默认是128。<br>max_user_watches 表示每个用户可创建的监控项（watch）的最大数量。监控项是 inotify 实例中用于监控文件或目录的对象。一般默认是 8192。<br> max_queued_events 表示每个 inotify 实例的事件队列的最大容量。事件队列用于存储待处理的事件通知。一般默认是16384。</li>
<li>监控路径的长度限制： 对于每个inotify实例，路径长度限制为通常是4096个字节。如果路径超过这个限制，inotify_add_watch函数会返回ENAMETOOLONG错误。</li>
<li>文件系统限制：大部分Linux文件系统都支持inotify。但网络文件系统（如 NFS）一般不支持 inotify。在使用 inotify 时，确保文件系统支持和兼容性。</li>
<li>事件溢出：如果事件队列满了，新的事件将被丢弃，这可能导致丢失重要的事件。可以通过适当调整事件队列的大小或及时处理事件来避免事件溢出。</li>
<li>性能开销：inotify 监控是实时的，对于大量文件或目录的监控可能带来较大的性能开销。可以通过使用批量处理、事件队列、并发处理等技术来优化性能，减少系统调用次数。</li>
<li>注意事件顺序：inotify 提供的事件顺序是不可靠的，即不能保证事件的顺序。在处理事件时，要谨慎处理，并避免对事件顺序有依赖的操作。</li>
</ol>
<h3 id="2-6-常见问题"><a href="#2-6-常见问题" class="headerlink" title="2.6 常见问题"></a>2.6 常见问题</h3><ol>
<li>实现监控子目录<br>除了监控单个文件，inotify还可以监控整个目录，但只能监控一级目录，二级及以下子目录是不支持的，需要通过inotify_add_watch添加子目录。建议单独启动线程遍历整个目录逐一添加，监控到创建子目录事件时，再添加到监控。</li>
<li>批量处理事件<br>当有大量事件到达时，处理每个事件可能会带来性能问题。可以考虑以下方式解决。</li>
</ol>
<ul>
<li>事件缓冲区： 创建一个事件缓冲区，用于存储inotify事件。当有新的事件到达时，将其添加到缓冲区中，而不立即处理事件。这样可以避免在处理一个事件时，另一个事件到达导致的中断。</li>
<li>事件合并： 如果多个事件发生在同一个文件上，并且这些事件之间的时间间隔很短，你可以考虑将它们合并为一个事件进行处理。例如，如果一个文件在短时间内连续被修改了多次，你可以只触发一次处理操作，而不是每次修改都触发。</li>
<li>并发处理： 使用多线程或多进程来并发处理事件。将事件分发给多个处理线程或进程，可以并行处理多个事件，提高处理速度。但要注意避免并发处理导致的竞态条件和资源冲突问题。</li>
</ul>
<ol start="3">
<li>无法追踪操作的进程。</li>
</ol>
<ul>
<li>结合进程监控工具：如 lsof、fuser 或 ltrace<br>局限：嵌入式设备系统上没有lsof、strace等命令。</li>
</ul>
<h1 id="三、fanotify简介"><a href="#三、fanotify简介" class="headerlink" title="三、fanotify简介"></a>三、fanotify简介</h1><p>特性与优势</p>
<ul>
<li>追踪操作文件的进程</li>
<li>支持操作阻断</li>
<li>支持整个目录监控，inotify仅支持一级目录监控，其子目录不在监控范围。<br>使用场景</li>
<li>文件安全监控与防篡改</li>
<li>行为分析与审计</li>
<li>实时反病毒扫描</li>
<li>文件同步和备份</li>
</ul>
<p>接口介绍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/fanotify.h&gt;</span><br><span class="line"></span><br><span class="line">int fanotify_init(unsigned int flags, unsigned int event_f_flags);</span><br><span class="line">/*</span><br><span class="line">flags: 通知类别</span><br><span class="line">  FAN_CLASS_NOTIF 默认值。不需要指定。该值仅允许接收通知的事件。</span><br><span class="line">  FAN_CLASS_CONTENT 监控文件或者目录状态变化，给出阻止/放行的决定</span><br><span class="line">  FAN_NONBLOCK 以非阻塞模式打开</span><br><span class="line">  FAN_CLOEXEC 在执行exec时会关闭fanotify文件描述符</span><br><span class="line">event_f_flags：文件状态标志，比如O_RDONLY O_RDONLY  O_LARGEFILE</span><br><span class="line">*/</span><br><span class="line">int fanotify_mark(int fanotify_fd, unsigned int flags, uint64_t mask, </span><br><span class="line">                int dirfd, const char*pathname);</span><br><span class="line">/*</span><br><span class="line">fanotify_fd：fanotify 文件描述符，通过 fanotify_init 函数获得。</span><br><span class="line">flags：标记选项，可以使用 FAN_MARK_ADD 或 FAN_MARK_REMOVE 进行添加或移除标记。</span><br><span class="line">mask：要监控的事件掩码，指定的事件类型。例如，FAN_OPEN | FAN_CLOSE_WRITE 表示你希望监控打开和写入关闭的事件。</span><br><span class="line">dirfd：目标文件或目录所在的文件描述符。</span><br><span class="line">pathname：目标文件或目录的路径。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">struct fanotify_event_metadata &#123;</span><br><span class="line">    __u32 event_len; //事件的长度，包括元数据结构体在内的整个事件的字节数。</span><br><span class="line">    __u8 vers; // fanotify 版本号。</span><br><span class="line">    __u8 reserved;</span><br><span class="line">    __u16 metadata_len; //元数据结构体的长度。</span><br><span class="line">    __aligned_u64 mask; //表示事件的掩码，指定了哪些事件发生时会触发 fanotify 通知。</span><br><span class="line">    __s32 fd; //与事件相关的文件描述符。</span><br><span class="line">    __s32 pid;//产生事件的进程的 PID。</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct fanotify_response &#123;</span><br><span class="line">    __s32 fd;</span><br><span class="line">    __u32 response;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Legit userspace responses to a _PERM event */</span><br><span class="line">#define FAN_ALLOW   0x01</span><br><span class="line">#define FAN_DENY    0x02</span><br><span class="line">#define FAN_AUDIT   0x10    /* Bit mask to create audit record for result */</span><br><span class="line"></span><br><span class="line">FAN_EVENT_OK(meta, len)</span><br><span class="line">FAN_EVENT_NEXT(meta, len)</span><br><span class="line">常见事件</span><br><span class="line">- FAN_ACCESS：文件被访问时触发事件。</span><br><span class="line">- FAN_MODIFY：文件被修改时触发事件。</span><br><span class="line">- FAN_CLOSE_WRITE：文件被写入并关闭时触发事件。</span><br><span class="line">- FAN_CLOSE_NOWRITE：文件被关闭而没有写入时触发事件。</span><br><span class="line">- FAN_OPEN：文件被打开时触发事件。</span><br><span class="line">- FAN_OPEN_PERM：文件被打开且检查了权限时触发事件。</span><br><span class="line">- FAN_ATTRIB：文件属性发生变化时触发事件。</span><br><span class="line">- FAN_CREATE：文件或目录被创建时触发事件。</span><br><span class="line">- FAN_DELETE：文件或目录被删除时触发事件。</span><br><span class="line">- FAN_DELETE_SELF：监控的文件或目录本身被删除时触发事件。</span><br><span class="line">- FAN_MOVE：文件或目录被移动时触发事件。</span><br><span class="line">- FAN_MOVE_SELF：监控的文件或目录本身被移动时触发事件。</span><br><span class="line">- FAN_CLOSE：文件被关闭时触发事件（包括写入和未写入的情况）。</span><br><span class="line">- FAN_ALL_EVENTS：所有事件的组合，用于方便地监控所有事件。</span><br></pre></td></tr></table></figure>

<p>fanotify实例演示<br>示例1<br>根据监控事件，获取对应修改文件的程序名称及被修改文件名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/signalfd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;linux/fanotify.h&gt;</span><br><span class="line"></span><br><span class="line">/* Structure to keep track of monitored directories */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  /* Path of the directory */</span><br><span class="line">  char *path;</span><br><span class="line">&#125; monitored_t;</span><br><span class="line"></span><br><span class="line">/* Size of buffer to use when reading fanotify events */</span><br><span class="line">#define FANOTIFY_BUFFER_SIZE 8192</span><br><span class="line"></span><br><span class="line">/* Enumerate list of FDs to poll */</span><br><span class="line">enum &#123;</span><br><span class="line">  FD_POLL_SIGNAL = 0,</span><br><span class="line">  FD_POLL_FANOTIFY,</span><br><span class="line">  FD_POLL_MAX</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Setup fanotify notifications (FAN) mask. All these defined in fanotify.h. */</span><br><span class="line">static uint64_t event_mask =</span><br><span class="line">  (FAN_ACCESS |         </span><br><span class="line">   FAN_MODIFY |         </span><br><span class="line">   FAN_CLOSE_WRITE |   </span><br><span class="line">   FAN_CLOSE_NOWRITE | </span><br><span class="line">   FAN_OPEN );</span><br><span class="line">/* Array of directories being monitored */</span><br><span class="line">static monitored_t *monitors;</span><br><span class="line">static int n_monitors;</span><br><span class="line"></span><br><span class="line">static char * get_program_name_from_pid (int     pid,char   *buffer,size_t  buffer_size)</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    ssize_t len;</span><br><span class="line">    char *aux;</span><br><span class="line"></span><br><span class="line">    /* Try to get program name by PID */</span><br><span class="line">    sprintf (buffer, &quot;/proc/%d/cmdline&quot;, pid);</span><br><span class="line">    if ((fd = open (buffer, O_RDONLY)) &lt; 0)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    /* Read file contents into buffer */</span><br><span class="line">    if ((len = read (fd, buffer, buffer_size - 1)) &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        close (fd);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    close (fd);</span><br><span class="line"></span><br><span class="line">    buffer[len] = &#x27;\0&#x27;;</span><br><span class="line">    aux = strstr (buffer, &quot;^@&quot;);</span><br><span class="line">    if (aux)</span><br><span class="line">        *aux = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static char * get_file_path_from_fd (int     fd, char   *buffer, size_t  buffer_size)</span><br><span class="line">&#123;</span><br><span class="line">    ssize_t len;</span><br><span class="line"></span><br><span class="line">    if (fd &lt;= 0)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    sprintf (buffer, &quot;/proc/self/fd/%d&quot;, fd);</span><br><span class="line">    if ((len = readlink (buffer, buffer, buffer_size - 1)) &lt; 0)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    buffer[len] = &#x27;\0&#x27;;</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void event_process (struct fanotify_event_metadata *event)</span><br><span class="line">&#123;</span><br><span class="line">    char path[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    printf (&quot;Received event in path &#x27;%s&#x27;&quot;,</span><br><span class="line">            get_file_path_from_fd (event-&gt;fd,path,PATH_MAX) ? path : &quot;unknown&quot;);</span><br><span class="line">    printf (&quot; pid=%d (%s): \n&quot;,event-&gt;pid,(get_program_name_from_pid (event-&gt;pid,path,</span><br><span class="line">            PATH_MAX) ? path : &quot;unknown&quot;));</span><br><span class="line"></span><br><span class="line">    if (event-&gt;mask &amp; FAN_OPEN)</span><br><span class="line">        printf (&quot;\tFAN_OPEN\n&quot;);</span><br><span class="line">    if (event-&gt;mask &amp; FAN_ACCESS)</span><br><span class="line">        printf (&quot;\tFAN_ACCESS\n&quot;);</span><br><span class="line">    if (event-&gt;mask &amp; FAN_MODIFY)</span><br><span class="line">        printf (&quot;\tFAN_MODIFY\n&quot;);</span><br><span class="line">    if (event-&gt;mask &amp; FAN_CLOSE_WRITE)</span><br><span class="line">        printf (&quot;\tFAN_CLOSE_WRITE\n&quot;);</span><br><span class="line">    if (event-&gt;mask &amp; FAN_CLOSE_NOWRITE)</span><br><span class="line">        printf (&quot;\tFAN_CLOSE_NOWRITE\n&quot;);</span><br><span class="line">    fflush (stdout);</span><br><span class="line"></span><br><span class="line">    close (event-&gt;fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void shutdown_fanotify (int fanotify_fd)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; n_monitors; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        /* Remove the mark, using same event mask as when creating it */</span><br><span class="line">        fanotify_mark (fanotify_fd,FAN_MARK_REMOVE,event_mask,AT_FDCWD,</span><br><span class="line">                        monitors[i].path);</span><br><span class="line">        free (monitors[i].path);</span><br><span class="line">    &#125;</span><br><span class="line">    free (monitors);</span><br><span class="line">    close (fanotify_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int initialize_fanotify (int argc, const char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int fanotify_fd;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    FAN_CLASS_NOTIF: 默认值，可以不配置</span><br><span class="line">    FAN_CLOEXEC: 表示在执行 exec 类系统调用时关闭 fanotify 文件描述符。使用这个标志位可以确保在子进程中不会继承 fanotify 的文件描述符。</span><br><span class="line">    O_RDONLY : 表示以只读模式打开文件</span><br><span class="line">    O_CLOEXEC : 表示在执行 exec 类系统调用时关闭文件描述符。</span><br><span class="line">    */</span><br><span class="line">    if ((fanotify_fd = fanotify_init (FAN_CLASS_NOTIF|FAN_CLOEXEC,O_RDONLY | O_CLOEXEC</span><br><span class="line">                                     | O_LARGEFILE)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      fprintf (stderr,</span><br><span class="line">               &quot;Couldn&#x27;t setup new fanotify device: %s\n&quot;,</span><br><span class="line">               strerror (errno));</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Allocate array of monitor setups */</span><br><span class="line">    n_monitors = argc - 1;</span><br><span class="line">    monitors = malloc (n_monitors * sizeof (monitored_t));</span><br><span class="line"></span><br><span class="line">    /* Loop all input directories, setting up marks */</span><br><span class="line">    for (i = 0; i &lt; n_monitors; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        monitors[i].path = strdup (argv[i + 1]);</span><br><span class="line">        /* Add new fanotify mark */</span><br><span class="line">        if (fanotify_mark (fanotify_fd,FAN_MARK_ADD,event_mask,AT_FDCWD,</span><br><span class="line">                    monitors[i].path) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">          fprintf (stderr,&quot;Couldn&#x27;t add monitor in directory &#x27;%s&#x27;: &#x27;%s&#x27;\n&quot;,</span><br><span class="line">                   monitors[i].path,strerror (errno));</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf (&quot;Started monitoring directory &#x27;%s&#x27;...\n&quot;, monitors[i].path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return fanotify_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void shutdown_signals (int signal_fd)</span><br><span class="line">&#123;</span><br><span class="line">    close (signal_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int initialize_signals (void)</span><br><span class="line">&#123;</span><br><span class="line">    int signal_fd;</span><br><span class="line">    sigset_t sigmask;</span><br><span class="line"></span><br><span class="line">    /* We want to handle SIGINT and SIGTERM in the signal_fd, so we block them. */</span><br><span class="line">    sigemptyset (&amp;sigmask);</span><br><span class="line">    sigaddset (&amp;sigmask, SIGINT);</span><br><span class="line">    sigaddset (&amp;sigmask, SIGTERM);</span><br><span class="line"></span><br><span class="line">    if (sigprocmask (SIG_BLOCK, &amp;sigmask, NULL) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf (stderr,&quot;Couldn&#x27;t block signals: &#x27;%s&#x27;\n&quot;,strerror (errno));</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* Get new FD to read signals from it */</span><br><span class="line">  if ((signal_fd = signalfd (-1, &amp;sigmask, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      fprintf (stderr,&quot;Couldn&#x27;t setup signal FD: &#x27;%s&#x27;\n&quot;,strerror (errno));</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return signal_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (int argc, const char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int signal_fd;</span><br><span class="line">    int fanotify_fd;</span><br><span class="line">    struct pollfd fds[FD_POLL_MAX];</span><br><span class="line"></span><br><span class="line">    /* Input arguments... */</span><br><span class="line">    if (argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf (stderr, &quot;Usage: %s directory1 [directory2 ...]\n&quot;, argv[0]);</span><br><span class="line">        exit (EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Initialize signals FD */</span><br><span class="line">    if ((signal_fd = initialize_signals ()) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf (stderr, &quot;Couldn&#x27;t initialize signals\n&quot;);</span><br><span class="line">        exit (EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Initialize fanotify FD and the marks */</span><br><span class="line">    if ((fanotify_fd = initialize_fanotify (argc, argv)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf (stderr, &quot;Couldn&#x27;t initialize fanotify\n&quot;);</span><br><span class="line">        exit (EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Setup polling */</span><br><span class="line">    fds[FD_POLL_SIGNAL].fd = signal_fd;</span><br><span class="line">    fds[FD_POLL_SIGNAL].events = POLLIN;</span><br><span class="line">    fds[FD_POLL_FANOTIFY].fd = fanotify_fd;</span><br><span class="line">    fds[FD_POLL_FANOTIFY].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        /* Block until there is something to be read */</span><br><span class="line">        if (poll (fds, FD_POLL_MAX, -1) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf (stderr,&quot;Couldn&#x27;t poll(): &#x27;%s&#x27;\n&quot;,strerror (errno));</span><br><span class="line">            exit (EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Signal received? */</span><br><span class="line">        if (fds[FD_POLL_SIGNAL].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            struct signalfd_siginfo fdsi;</span><br><span class="line">            if (read (fds[FD_POLL_SIGNAL].fd,&amp;fdsi, sizeof (fdsi)) != sizeof (fdsi))</span><br><span class="line">            &#123;</span><br><span class="line">                fprintf (stderr,&quot;Couldn&#x27;t read signal, wrong size read\n&quot;);</span><br><span class="line">                exit (EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* Break loop if we got the expected signal */</span><br><span class="line">            if (fdsi.ssi_signo == SIGINT || fdsi.ssi_signo == SIGTERM)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            fprintf (stderr,&quot;Received unexpected signal\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (fds[FD_POLL_FANOTIFY].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            char buffer[FANOTIFY_BUFFER_SIZE];</span><br><span class="line">            ssize_t length;</span><br><span class="line"></span><br><span class="line">            /* Read from the FD. It will read all events available up to</span><br><span class="line">            * the given buffer size. */</span><br><span class="line">            if ((length = read (fds[FD_POLL_FANOTIFY].fd,buffer,FANOTIFY_BUFFER_SIZE)) &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                struct fanotify_event_metadata *metadata;</span><br><span class="line"></span><br><span class="line">                metadata = (struct fanotify_event_metadata *)buffer;</span><br><span class="line">                while (FAN_EVENT_OK (metadata, length))</span><br><span class="line">                &#123;</span><br><span class="line">                    event_process (metadata);</span><br><span class="line">                    if (metadata-&gt;fd &gt; 0)</span><br><span class="line">                    close (metadata-&gt;fd);</span><br><span class="line">                    metadata = FAN_EVENT_NEXT (metadata, length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* Clean exit */</span><br><span class="line">  shutdown_fanotify (fanotify_fd);</span><br><span class="line">  shutdown_signals (signal_fd);</span><br><span class="line"></span><br><span class="line">  printf (&quot;Exiting fanotify example...\n&quot;);</span><br><span class="line"></span><br><span class="line">  return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例2<br>拦截访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/fanotify.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_EVENTS 10</span><br><span class="line">#define EVENT_SIZE (sizeof(struct fanotify_event_metadata) + 100)</span><br><span class="line">#define BUFFER_SIZE (MAX_EVENTS * EVENT_SIZE)</span><br><span class="line"></span><br><span class="line">int main(int argc, const char **argv) &#123;</span><br><span class="line">    char *path = (char *)argv[1];</span><br><span class="line"></span><br><span class="line">    int fanotify_fd = fanotify_init(FAN_CLASS_CONTENT | FAN_CLOEXEC , O_RDONLY );</span><br><span class="line"></span><br><span class="line">    if (fanotify_fd == -1) &#123;</span><br><span class="line">        perror(&quot;fanotify_init&quot;);</span><br><span class="line">        exit(EXIT_FAILURE); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int wd = fanotify_mark(fanotify_fd, FAN_MARK_ADD, FAN_OPEN_PERM, AT_FDCWD, path);</span><br><span class="line"></span><br><span class="line">    if (wd == -1) &#123;</span><br><span class="line">        perror(&quot;fanotify_mark&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char buffer[BUFFER_SIZE];</span><br><span class="line">    ssize_t len;</span><br><span class="line">    struct fanotify_event_metadata *metadata;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        len = read(fanotify_fd, buffer, sizeof(buffer));</span><br><span class="line">        if (len == -1) &#123;</span><br><span class="line">            perror(&quot;read&quot;);</span><br><span class="line">            exit(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        metadata = (struct fanotify_event_metadata *)buffer;</span><br><span class="line"></span><br><span class="line">        while (FAN_EVENT_OK(metadata, len)) &#123;</span><br><span class="line">            if (metadata-&gt;mask &amp; FAN_OPEN_PERM) &#123;</span><br><span class="line">                printf(&quot;FAN_OPEN_PERM\n&quot;);</span><br><span class="line">                struct fanotify_response response;</span><br><span class="line">                response.fd = metadata-&gt;fd;</span><br><span class="line">                response.response = FAN_DENY; //FAN_ALLOW</span><br><span class="line"></span><br><span class="line">                // 发送阻拦响应</span><br><span class="line">                if (write(fanotify_fd, &amp;response, sizeof(response)) != sizeof(response)) &#123;</span><br><span class="line">                    perror(&quot;write&quot;);</span><br><span class="line">                    exit(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fflush (stdout);</span><br><span class="line"></span><br><span class="line">            close (metadata-&gt;fd);</span><br><span class="line"></span><br><span class="line">            // 进一步处理其他事件...</span><br><span class="line"></span><br><span class="line">            metadata = FAN_EVENT_NEXT(metadata, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截流程：<br><img src="/../images/%E6%B5%81%E7%A8%8B.png" alt="图片"></p>
<p>注意事项</p>
<ul>
<li>特权要求：fanotify需要root权限，请确保你有足够的权限来进行文件系统监控。</li>
<li>监控范围：fanotify 可以用于监控整个文件系统，若文件数量太过庞大，面临性能瓶颈和资源限制。</li>
<li>兼容性：fanotify 是 Linux 特定的机制，在其他操作系统或平台上可能不可用或工作方式不同。确保你的应用程序的目标环境支持 fanotify。</li>
</ul>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">↑</a>
  </div>
</article>
<footer>
  &copy; 2023
  <span class="author">
    betta
  </span>
</footer>

    </div>
  </body>
</html>
