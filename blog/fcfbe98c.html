<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>OpenResty Note - B</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=betta-cyber, game, betta, shokill>
  
    <meta name="description" content="betta">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="B" type="application/atom+xml">
  

  

  

  <!-- <link rel="stylesheet" href="../css/style.css"> -->
  
<link rel="stylesheet" href="/css/style.css">


  <!--  -->
    <!-- <link rel="stylesheet" href="../css/font-awesome.min.css"> -->
  <!--  -->

  <script src="/static/js/hexo_resize_image.js"></script>

  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script> -->
  <script type='text/javascript' id='clustrmaps' src='//cdn.clustrmaps.com/map_v2.js?cl=ffffff&w=0&t=n&d=b9cDq33TdEsfGb_DpY--uB2pjskzQ8TK9LaE3yuIYzE&co=ffffff&cmo=ffffff&cmn=ffffff&ct=ffffff'></script>
<meta name="generator" content="Hexo 5.4.1"></head>

  <body>
    <div class="container">
      <header class="header">
  <!-- <div class="blog-title">
    <a href="/" class="logo">B</a>
    <div class="subtitle"></div>
  </div> -->
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link " >Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/blog" class="menu-item-link active" >Blog</a>
        </li>
      
        <li class="menu-item">
          <a href="/ebook" class="menu-item-link " >Ebook</a>
        </li>
      
        <li class="menu-item">
          <a href="/music" class="menu-item-link " >Music</a>
        </li>
      
        <li class="menu-item">
          <a href="/album" class="menu-item-link " >Photo</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link " >About</a>
        </li>
      
    </ul>
  </nav>
</header>


<article class="post">
  <div class="post-title">
    <h1 class="article-title">OpenResty Note</h1>
  </div>
  <div class="post-content">
    <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="lua-resty-core"><a href="#lua-resty-core" class="headerlink" title="lua-resty-core"></a>lua-resty-core</h2><p>在核心的 lua-nginx-module 中，调用 C 函数的 API，都是使用 Lua C API 来完成的；<br>而在 lua-resty-core 中，则是把 lua-nginx-module 已有的部分 API，使用 FFI 的模式重新实现了一遍。</p>
<p>LuaJIT 只负责由自己分配的资源；而 ffi.C 是 C 库的命名空间，<br>所以，使用 ffi.C 分配的空间不由 LuaJIT 负责，需要你自己手动释放。&#96;</p>
<p>FFI 的方式不仅代码更简洁，而且可以被 LuaJIT 优化，显然是更优的选择。其实现实也是如此，<br>实际上，CFunction 的实现方式已经被 OpenResty 废弃，相关的实现也从代码库中移除了。现在新的 API，都通过 FFI 的方式，在 lua-resty-core 仓库中实现。</p>
<h2 id="NYI"><a href="#NYI" class="headerlink" title="NYI"></a>NYI</h2><p>编译器的死穴。</p>
<p>LuaJIT 的运行时环境，除了一个汇编实现的 Lua 解释器外，还有一个可以直接生成机器代码的 JIT 编译器。</p>
<p>LuaJIT 中 JIT 编译器的实现还不完善，有一些原语它还无法编译，因为这些原语实现起来比较困难，再加上 LuaJIT 的作者目前处于半退休状态。这些原语包括常见的 pairs() 函数、unpack() 函数、基于 Lua CFunction 实现的 Lua C 模块等。这样一来，当 JIT 编译器在当前代码路径上遇到它不支持的操作时，便会退回到解释器模式。</p>
<p>完整的<a target="_blank" rel="noopener" href="http://wiki.luajit.org/NYI">NYI列表</a></p>
<pre><code class="highlight plaintext">resty -j v -e &#x27;local t = &#123;&#125;
for i=1,100 do
    t[i] = i
end

for i=1, 1000 do
    for j=1,1000 do
        for k,v in pairs(t) do
            --
        end
    end
end&#x27;</code></pre>
<p>output</p>
<pre><code class="highlight plaintext">[TRACE   1 (command line -e):2 loop]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):6 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):6 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):6 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):6 -- NYI: bytecode 72 at (command line -e):8]
[TRACE --- (command line -e):6 -- NYI: bytecode 72 at (command line -e):8]</code></pre>

<p>If could be JIT:</p>
<pre><code class="highlight plaintext">resty -j v -e &#x27;for i=1, 1000 do local newstr, n, err = ngx.re.gsub(&quot;hello, world&quot;, &quot;([a-z])[a-z]+&quot;, &quot;[$0,$1]&quot;, &quot;i&quot;) end&#x27;</code></pre>

<p>output:</p>
<pre><code class="highlight plaintext">[TRACE   1 regex.lua:1081 loop]
[TRACE --- (command line -e):1 -- inner loop in root trace at regex.lua:1082]
[TRACE   2 (1/10) regex.lua:1116 -&gt; 1]
[TRACE   3 (1/21) regex.lua:1084 -&gt; 1]</code></pre>
<p>every code could be traced</p>
<h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>千万不要在热代码路径上拼接字符串：</p>
<pre><code class="highlight plaintext">
--No
local s = &quot;&quot;
for i = 1, 100000 do
    s = s .. &quot;a&quot;
end</code></pre>


<pre><code class="highlight plaintext">--Yes
local t = &#123;&#125;
for i = 1, 100000 do
    t[i] = &quot;a&quot;
end
local s =  table.concat(t, &quot;&quot;)</code></pre>

<h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><p>为了风格的统一，require 和 ngx 也需要 local 化：</p>
<pre><code class="highlight plaintext">local ngx = ngx
local require = require</code></pre>

<h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑"></a>常见的坑</h2><h3 id="下标从-0-开始还是从-1-开始"><a href="#下标从-0-开始还是从-1-开始" class="headerlink" title="下标从 0 开始还是从 1 开始"></a>下标从 0 开始还是从 1 开始</h3><p>第一个坑，Lua 的下标是从 1 开始的</p>
<p>在 LuaJIT 中，使用 ffi.new 创建的数组，下标又是从 0 开始的:</p>
<pre><code class="highlight plaintext">local buf = ffi_new(&quot;char[?]&quot;, 128)</code></pre>

<p>所以，如果你要访问上面这段代码中 buf 这个 cdata，请记得下标从 0 开始，而不是 1。</p>
<h2 id="luacheck"><a href="#luacheck" class="headerlink" title="luacheck"></a>luacheck</h2><p><a target="_blank" rel="noopener" href="https://github.com/mpeterv/luacheck">luacheck</a></p>
<p>install luacheck by luarocks</p>
<pre><code class="highlight plaintext">luarocks install luacheck</code></pre>

<h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><pre><code class="highlight plaintext">luacheck src extra_file.lua another_file.lua</code></pre>

<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><p><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html#variables">完整的 NGINX 内置变量列表</a></p>
<p>既然可以通过ngx.var.* 这种返回变量值的方法，来得到请求行中的数据，为什么 OpenResty 还要单独提供针对请求行的 API 呢？</p>
<p>比如ngx.req.get_method</p>
<p>这其实是很多方面因素的综合考虑结果：</p>
<ul>
<li>首先是对性能的考虑。ngx.var 的效率不高，不建议反复读取；</li>
<li>也有对程序友好的考虑，ngx.var 返回的是字符串，而非 Lua 对象，遇到获取 args 这种可能返回多个值的情况，就不好处理了；</li>
<li>另外是对灵活性的考虑，绝大部分的 ngx.var 是只读的，只有很少数的变量是可写的，比如 $args 和 limit_rate，可很多时候，我们会有修改 method、URI 和 args 的需求。</li>
</ul>
<h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><p>改写和删除请求头</p>
<pre><code class="highlight plaintext">ngx.req.set_header(&quot;Content-Type&quot;, &quot;text/css&quot;)
ngx.req.clear_header(&quot;Content-Type&quot;)</code></pre>

<h2 id="响应状态行"><a href="#响应状态行" class="headerlink" title="响应状态行"></a>响应状态行</h2><p>状态行中，我们主要关注的是状态码。在默认情况下，返回的 HTTP 状态码是 200，也就是 OpenResty 中内置的常量 ngx.HTTP_OK。但在代码的世界中，处理异常情况的代码总是占比最多的。如果你检测了请求报文，发现这是一个恶意的请求，那么你需要终止请求:</p>
<pre><code class="highlight plaintext">ngx.exit(ngx.HTTP_BAD_REQUEST)</code></pre>

<p>不过，OpenResty 的 HTTP 状态码中，有一个特别的常量：ngx.OK。当 ngx.exit(ngx.OK) 时，请求会退出当前处理阶段，进入下一个阶段，而不是直接返回给客户端。</p>
<p>ngx.OK 确实不是http状态码，它是 OpenResty 中的一个常量，值是0.<br>ngx.exit 的官方文档正好可以解答你的问题：</p>
<pre><code class="highlight plaintext">When status &gt;= 200 (i.e., ngx.HTTP_OK and above), it will interrupt the execution of the current request and return status code to nginx.

When status == 0 (i.e., ngx.OK), it will only quit the current phase handler (or the content handler if the content_by_lua* directive is used) and continue to run later phases (if any) for the current request.</code></pre>

<p>不过，里面并没有提到对于ngx.exit(ngx.ERROR)和ngx.exit(ngx.DECLINED)是如何处理的，我们可以自己来做个测试：</p>
<pre><code class="highlight plaintext">location /lua &#123;
    rewrite_by_lua &quot;ngx.exit(ngx.ERROR)&quot;;
    echo hello;
&#125;</code></pre>
<p>访问这个 location，可以看到 http 响应码为空，响应体也是空。并没有引入下一个执行阶段。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module/#http-status-constants">更多状态行</a></p>
<h2 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h2><p>基于 shared dict，你可以实现多个 worker 之间的缓存和通信，以及限流限速、流量统计等功能。你可以把 shared dict 当作简单的 Redis 来使用，只不过 shared dict 中的数据不能持久化，所以你存放在其中的数据，一定要考虑到丢失的情况。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module#ngxshareddict">sharddict文档</a></p>
<h2 id="cosocket"><a href="#cosocket" class="headerlink" title="cosocket"></a>cosocket</h2><p>cosocket 是 OpenResty 中的专有名词，是把协程和网络套接字的英文拼在一起形成的，即 cosocket &#x3D; coroutine + socket。所以，你可以把 cosocket 翻译为“协程套接字”。</p>
<p><img src="https://static001.geekbang.org/resource/image/80/06/80d16e11d2750d6e4127445c126c9f06.png" alt="cosocket"></p>
<p>从图中你可以看到，用户的 Lua 脚本每触发一个网络操作，都会有协程的 yield 以及 resume。遇到网络 I&#x2F;O 时，它会交出控制权（yield），把网络事件注册到 Nginx 监听列表中，并把权限交给 Nginx；当有 Nginx 事件达到触发条件时，便唤醒对应的协程继续处理（resume）。</p>
<p>OpenResty 正是以此为蓝图，封装实现 connect、send、receive 等操作，形成了我们如今见到的 cosocket API。</p>
<h3 id="cosocket-API-和指令简介"><a href="#cosocket-API-和指令简介" class="headerlink" title="cosocket API 和指令简介"></a>cosocket API 和指令简介</h3><p>TCP 相关的 cosocket API 可以分为下面这几类。</p>
<ul>
<li>创建对象：ngx.socket.tcp。</li>
<li>设置超时：tcpsock:settimeout 和 tcpsock:settimeouts。</li>
<li>建立连接：tcpsock:connect。</li>
<li>发送数据：tcpsock:send。</li>
<li>接受数据：tcpsock:receive、tcpsock:receiveany 和 tcpsock:receiveuntil。</li>
<li>连接池：tcpsock:setkeepalive。</li>
<li>关闭连接：tcpsock:close。</li>
</ul>
<h2 id="privileged-process"><a href="#privileged-process" class="headerlink" title="privileged process"></a>privileged process</h2><pre><code class="highlight plaintext">
init_by_lua_block &#123;
    local process = require &quot;ngx.process&quot;

    local ok, err = process.enable_privileged_agent()
    if not ok then
        ngx.log(ngx.ERR, &quot;enables privileged agent failed error:&quot;, err)
    end
&#125;</code></pre>
<p>特权只在 init_worker_by_lua 阶段运行一次，既然它不监听端口，也就是不能被终端请求触发，那就只有使用我们刚才介绍的 ngx.timer ，来周期性地触发了</p>
<p>example</p>
<pre><code class="highlight plaintext">init_worker_by_lua_block &#123;
    local process = require &quot;ngx.process&quot;

    local function reload(premature)
        local f, err = io.open(ngx.config.prefix() .. &quot;/logs/nginx.pid&quot;, &quot;r&quot;)
        if not f then
            return
        end
        local pid = f:read()
        f:close()
        os.execute(&quot;kill -HUP &quot; .. pid)
    end

    if process.type() == &quot;privileged agent&quot; then
         local ok, err = ngx.timer.every(5, reload)
        if not ok then
            ngx.log(ngx.ERR, err)
        end
    end
&#125;</code></pre>
<h2 id="非阻塞的-ngx-pipe"><a href="#非阻塞的-ngx-pipe" class="headerlink" title="非阻塞的 ngx.pipe"></a>非阻塞的 ngx.pipe</h2><pre><code class="highlight plaintext">os.execute(&quot;kill -HUP &quot; .. pid)</code></pre>
<p>会导致阻塞，这显然是不好的。</p>
<p>为此，lua-resty-shell 库应运而生，使用它来调用命令行就是非阻塞的：</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>这些返回当前时间的 API，如果没有非阻塞网络 IO 操作来触发，便会一直返回缓存的值，而不是像我们想的那样，能够返回当前的实时时间。</p>
<pre><code class="highlight plaintext">
$ resty -e &#x27;ngx.say(ngx.now())
os.execute(&quot;sleep 1&quot;)
ngx.say(ngx.now())&#x27;</code></pre>

<p>在两次调用 ngx.now 之间，我们使用 Lua 的阻塞函数 sleep 了 1 秒钟，但从打印的结果来看，这两次返回的时间戳却是一模一样的。</p>
<p>如果换成是非阻塞的 sleep 函数</p>
<pre><code class="highlight plaintext">
$ resty -e &#x27;ngx.say(ngx.now())
ngx.sleep(1)
ngx.say(ngx.now())&#x27;</code></pre>

<p>显然，它就会打印出不同的时间戳了。</p>
<p>Nginx 是以性能优先作为设计理念的，它会把时间缓存下来。从 ngx.now 的源码中我们可以得到印证：</p>
<pre><code class="highlight plaintext">static int
ngx_http_lua_ngx_now(lua_State *L)
&#123;
    ngx_time_t *tp;

    tp = ngx_timeofday();

    lua_pushnumber(L, (lua_Number) (tp-&gt;sec + tp-&gt;msec / 1000.0L));

    return 1;
&#125;</code></pre>


<p>是调用了 Nginx 中的 ngx_timeofday 函数获取的时间。<br>而这个函数其实是一个宏定义：<br>&#96;&#96;#define ngx_timeofday() (ngx_time_t *) ngx_cached_time&#96;</p>
<p>而 ngx_cached_time 的值只在函数 ngx_time_update 中会更新。<br>那问题就简化为 ngx_time_update 什么时候会被调用。如果你在 Nginx 的源码中去跟踪它的话，就会发现ngx_time_update的调用比较多，在事件循环中都有出现。</p>
<p>也就是说只有在调用了 ngx_timer_update 的时候，ngx.timer的值才会更新，而调用前者多是在事件循环中，而调用yield 函数通常是添加了一个事件。这样解释了需要yield操作之后，ngx.timer才会更新</p>
<p>这里顺带引出了 ngx.sleep ，这个非阻塞的 sleep 函数。这个函数除了可以休眠指定的时间外，还有另外一个特别的用处。</p>
<p>举个例子，比如你有一段正在做密集运算的代码，需要花费比较多的时间，那么在这段时间内，这段代码对应的请求就会一直占用着 worker 和 CPU 资源，导致其他请求需要排队，无法得到及时的响应。这时，我们就可以在其中穿插 ngx.sleep(0)，使这段代码让出控制权，让其他请求也可以得到处理。</p>
<h2 id="nginx-null"><a href="#nginx-null" class="headerlink" title="nginx.null"></a>nginx.null</h2><p><em>只有 nil 和 false 是假值</em></p>
<h2 id="CVE-2018-9230"><a href="#CVE-2018-9230" class="headerlink" title="CVE-2018-9230"></a>CVE-2018-9230</h2><p>OpenResty 中的 ngx.req.get_uri_args、ngx.req.get_post_args 和 ngx.req.get_headers接口，默认只返回前 100 个参数。如果 WAF 的开发者没有注意到这个细节，就会被参数溢出的方式攻击。攻击者可以填入 100 个无用参数，把 payload 放在第 101 个参数中，借此绕过 WAF 的检测。</p>
<p>最终，OpenResty 维护者选择新增一个 err 的返回值来解决这个问题。如果输入参数超过 100 个，err 的提示信息就是 truncated。这样一来，这些 API 的调用者就必须要处理错误信息，自行判断拒绝请求还是放行。</p>
<p>ngx.req.get_uri_args(max_args?) 其实是有参数的。默认为100个。官方建议设置为0，可以接收所有的参数。但是不建议设置为0，因为这样会造成大量的系统占用。造成DDOS攻击。</p>
<p><em>返回函数有错误，一定要做错误处理!!!</em></p>
<h2 id="变量竞争问题"><a href="#变量竞争问题" class="headerlink" title="变量竞争问题"></a>变量竞争问题</h2><p>关于变量竞争的问题，其实，只要两个操作之间有 yield 操作，就可能出现竞争，而不是阻塞操作；有阻塞操作时是不会出现竞争的。换句话说，只要你不把主动权交给 Nginx 的事件循环，就不会有竞争。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="test-nginx"><a href="#test-nginx" class="headerlink" title="test::nginx"></a>test::nginx</h2><p>“自动化测试”和“持续集成”</p>
<p>test::nginx 糅合了 Perl、数据驱动以及 DSL（领域小语言）。对于同一份测试案例集，通过对参数和环境变量的控制，可以实现乱序执行、多次重复、内存泄漏检测、压力测试等不同的效果。</p>
<p>推荐 travis 中安装，其他方式的安装总是会遇到各种各样的问题。具体参考<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/109506">这里</a></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="string-1"><a href="#string-1" class="headerlink" title="string"></a>string</h2><p>理念一：处理请求要短、平、快</p>
<ul>
<li>这里提到的“短”，是指请求的生命周期要短，不要长时间占用资源而不释放；即使是长连接，也要设定一个时间或者请求次数的阈值，来定期地释放资源。</li>
<li>第二个字“平”，则是指在一个 API 中只做一件事情。要把复杂的业务逻辑拆散为多个 API，保持代码的简洁。</li>
<li>最后的“快”，是指不要阻塞主线程，不要有大量 CPU 运算。即使是不得不有这样的逻辑，也别忘了咱们上节课介绍的方法，要配合其他的服务去完成。</li>
</ul>
<p>理念二：避免产生中间数据</p>
<h2 id="用好-table"><a href="#用好-table" class="headerlink" title="用好 table"></a>用好 table</h2><p>尽量复用，避免不必要的 table 创建。</p>
<h3 id="预先生成数组"><a href="#预先生成数组" class="headerlink" title="预先生成数组"></a>预先生成数组</h3><pre><code class="highlight plaintext">
local new_tab = require &quot;table.new&quot;
local t = new_tab(100, 0)
for i = 1, 100 do
  t[i] = i
end</code></pre>

<h3 id="自己计算-table-下标"><a href="#自己计算-table-下标" class="headerlink" title="自己计算 table 下标"></a>自己计算 table 下标</h3><p>lua-resty-redis example</p>
<pre><code class="highlight plaintext">local function _gen_req(args)
    local nargs = #args


    local req = new_tab(nargs * 5 + 1, 0)
    req[1] = &quot;*&quot; .. nargs .. &quot;\r\n&quot;
    local nbits = 2


    for i = 1, nargs do
        local arg = args[i]
        req[nbits] = &quot;$&quot;
        req[nbits + 1] = #arg
        req[nbits + 2] = &quot;\r\n&quot;
        req[nbits + 3] = arg
        req[nbits + 4] = &quot;\r\n&quot;
        nbits = nbits + 5
    end
    return req
end</code></pre>
<h3 id="循环使用单个-table"><a href="#循环使用单个-table" class="headerlink" title="循环使用单个 table"></a>循环使用单个 table</h3><pre><code class="highlight plaintext">
local local_plugins = &#123;&#125;

function load()
    core.table.clear(local_plugins)


    local local_conf = core.config.local_conf()
    local plugin_names = local_conf.plugins


    local processed = &#123;&#125;
    for _, name in ipairs(plugin_names) do
        if processed[name] == nil then
            processed[name] = true
            insert_tab(local_plugins, name)
        end
    end


    return local_plugins</code></pre>

<h3 id="table-池"><a href="#table-池" class="headerlink" title="table 池"></a>table 池</h3><p>lua-tablepool 官方库</p>
<pre><code class="highlight plaintext">local tablepool = require &quot;tablepool&quot;
 local tablepool_fetch = tablepool.fetch
 local tablepool_release = tablepool.release


local pool_name = &quot;some_tag&quot;
local function do_sth()
     local t = tablepool_fetch(pool_name, 10, 0)
     -- -- using t for some purposes
    tablepool_release(pool_name, t)
end</code></pre>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">↑</a>
  </div>
</article>
<footer>
  &copy; 2024
  <span class="author">
    betta
  </span>
</footer>

    </div>
  </body>
</html>
