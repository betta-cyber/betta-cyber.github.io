<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>微信消息备份 - B</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=betta-cyber, game, betta, shokill>
  
    <meta name="description" content="betta">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="B" type="application/atom+xml">
  

  

  

  <!-- <link rel="stylesheet" href="../css/style.css"> -->
  
<link rel="stylesheet" href="/css/style.css">


  <!--  -->
    <!-- <link rel="stylesheet" href="../css/font-awesome.min.css"> -->
  <!--  -->

  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script> -->
  <script type='text/javascript' id='clustrmaps' src='//cdn.clustrmaps.com/map_v2.js?cl=ffffff&w=0&t=n&d=b9cDq33TdEsfGb_DpY--uB2pjskzQ8TK9LaE3yuIYzE&co=ffffff&cmo=ffffff&cmn=ffffff&ct=ffffff'></script>
<meta name="generator" content="Hexo 5.4.1"></head>

  <body>
    <div class="container">
      <header class="header">
  <!-- <div class="blog-title">
    <a href="/" class="logo">B</a>
    <div class="subtitle"></div>
  </div> -->
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link " >Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/blog" class="menu-item-link active" >Blog</a>
        </li>
      
        <li class="menu-item">
          <a href="/ebook" class="menu-item-link " >Ebook</a>
        </li>
      
        <li class="menu-item">
          <a href="/music" class="menu-item-link " >Music</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link " >About</a>
        </li>
      
    </ul>
  </nav>
</header>


<article class="post">
  <div class="post-title">
    <h1 class="article-title">微信消息备份</h1>
  </div>
  <div class="post-content">
    <h2 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h2><p>小乖和我的微信聊天记录，因为我的原因被删除了，好可惜，我这里还有一份，想着可以导出来一份给小乖，于是做了这次尝试。</p>
<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><p>MSGx.db文件一般用AES的64位密钥加密，微信在运行时会将该 aes key 放在内存里，因此我们只要知道 aes key 到基地址的偏移距离+基地址得到密钥地址，从而读取并解码，用于破解该数据库，最终用数据库软件打开就好。</p>
<p>假设微信信息存放在目录 <code>wechat_root=~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/xxx_version/xxx</code> 下的相关AES加密的sqlite3数据库文件中：</p>
<p>联系人: wechat_root&#x2F;Contanct&#x2F;wccontact_new2.db<br>群聊: wechat_root&#x2F;Group&#x2F;group_new.db<br>聊天记录: wechat_root&#x2F;Message&#x2F;msg_xxx.db<br>想办法解密数据库文件就可以获取到想要的信息了。</p>
<h2 id="AES-Key-获取"><a href="#AES-Key-获取" class="headerlink" title="AES Key 获取"></a>AES Key 获取</h2><p>macOS 上面的流程是：<br>打开微信客户端, 先不要登录，下调试断点</p>
<pre><code class="highlight plaintext">lldb -p $(pgrep WeChat)
br set -n sqlite3_key
continue</code></pre>
<p>然后登录微信</p>
<p>登录之后，这时候电脑端微信是会卡在登陆界面的，不需要担心，回到Terminal</p>
<pre><code class="highlight bash">Process 1390 resuming
Process 1390 stopped
* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span>
    frame <span class="comment">#0: 0x0000000107503cc4 WCDB`sqlite3_key</span>
WCDB`sqlite3_key:
-&gt;  0x107503cc4 &lt;+0&gt;:  mov    x3, x2
    0x107503cc8 &lt;+4&gt;:  mov    x2, x1
    0x107503ccc &lt;+8&gt;:  adr    x1, <span class="comment">#0x2c4d7              ; &quot;main&quot;</span>
    0x107503cd0 &lt;+12&gt;: nop
Target 0: (WeChat) stopped.</code></pre>


<p>输入<code>memory read --size 1 --format x --count 32 x1</code>，回车</p>
<p>上边打印的即为256-bit的aes key<br>你会看到类似如下的输出</p>
<pre><code class="highlight bash">0x60000243xxxx: 0xe8 0x8d 0x4a 0xd0 0x82 0x6a 0xe2 0x8f
0x60000243xxxx: 0x77 0x70 0x54 0xd4 0x8e 0x72 0x3a 0x1b
0x60000243xxxx: 0x0a 0xe7 0x9c 0x89 0x5f 0x49 0xb0 0xec
0x60000243xxxx: 0x79 0xdf 0x2a 0x68 0xd5 0x9c 0xb8 0xf5</code></pre>
<p>这个就是我们要的 aes key。</p>
<h2 id="macOS-安全机制问题"><a href="#macOS-安全机制问题" class="headerlink" title="macOS 安全机制问题"></a>macOS 安全机制问题</h2><pre><code class="highlight plaintext">(lldb) process attach --pid 59186
error: attach failed: attach failed (Not allowed to attach to process. Look in the console messages (Console.app), near the debugserver entries when the attached failed. The subsystem that denied the attach permission will likely have logged an informative message about why it was denied.)</code></pre>

<p>lldb 的时候存在错误，确认是 macOS的安全机制问题。</p>
<p>搜索关键字 “macos m1 crsutil”， 得到答案。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/360720953">https://zhuanlan.zhihu.com/p/360720953</a></p>
<p>苹果 M1 Mac 电脑为了系统环境安全，再核心下引入了SIP（System Integrity Protection），又称Rootless mode机制，要进行设备的升级或者重刷就要将该机制关闭才能操作，因此我们必须要关闭SIP。</p>
<ol>
<li>苹果M1 Mac关机状态下长按开机键，直到出现设置后松开，进入恢复模式。</li>
<li>按住开机键不松手直到出现画面，然后点击【选项】</li>
<li>点击实用工具&gt;点击终端。</li>
<li>终端内输入命令：<code>csrutil disable</code></li>
<li>出现 System Integrity Protection is off. 证明 SIP 已成功关闭。</li>
<li>reboot</li>
</ol>
<p>当然关闭 SIP 也存在风险，具体见 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/40239893">https://www.zhihu.com/question/40239893</a></p>
<h2 id="处理-aes-key"><a href="#处理-aes-key" class="headerlink" title="处理 aes key"></a>处理 aes key</h2><pre><code class="highlight python"><span class="comment"># -*- coding: utf-8 -*-</span>

ori_key = <span class="string">&quot;&quot;&quot;</span>
<span class="string">0x6000037c5c40: 0xf6 0xf0 0xf7 0xee 0xce 0xef 0x43 0xd9</span>
<span class="string">0x6000037c5c48: 0x9b 0x19 0xf5 0xe2 0xc8 0x7b 0xc5 0x54</span>
<span class="string">0x6000037c5c50: 0x16 0x9e 0x99 0x2d 0x39 0x1d 0x40 0xc6</span>
<span class="string">0x6000037c5c58: 0x9b 0xc7 0x21 0x0e 0xd8 0xc7 0xbe 0x7a</span>
<span class="string">&quot;&quot;&quot;</span>

key = <span class="string">&#x27;0x&#x27;</span> + <span class="string">&#x27;&#x27;</span>.join(i.partition(<span class="string">&#x27;:&#x27;</span>)[<span class="number">2</span>]
               .replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>)
               .replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> ori_key.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">1</span>:<span class="number">5</span>])
<span class="built_in">print</span>(key)</code></pre>

<p>得到 aes key。这串密钥对于后续所有*.db文件是通用的。</p>
<h2 id="获取微信聊天记录"><a href="#获取微信聊天记录" class="headerlink" title="获取微信聊天记录"></a>获取微信聊天记录</h2><p>可以使用 DB Brower 这种图形化界面的软件查看，也可以写脚本查看。</p>
<p>SQLCipher 3 default Raw key 模式输入前面得到的 aes key。</p>
<p>每一个Table代表你与一个人&#x2F;群的聊天记录。</p>
<ul>
<li>mesLocalID：primary key，</li>
<li>mesMesSvrID：服务端消息ID，</li>
<li>msgCreateTime：消息创建时间（Unix time）</li>
<li>msgContent：消息内容（格式为普通文本或XML）</li>
<li>msgStatus：消息状态（3表示发送出去的消息，4表示收到的消息）</li>
<li>msgImgStatus：图片状态</li>
<li>messgaeType：消息类型（1表示普通文本，3表示图片，34表示语音，43表示视频，47表示表情包，48表示位置，49是分享消息）</li>
<li>msgSource：消息来源（仅针对收到的消息）每一个Table代表你与一个人&#x2F;群的聊天记录。</li>
</ul>
<pre><code class="highlight python"><span class="comment">#! /usr/bin/env python3</span>
<span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> hmac
<span class="keyword">import</span> ctypes
<span class="keyword">import</span> hashlib
<span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES

<span class="keyword">def</span> <span class="title function_">decrypt_msg</span>(<span class="params">path, password</span>):
    KEY_SIZE = <span class="number">32</span>
    DEFAULT_ITER = <span class="number">64000</span>
    DEFAULT_PAGESIZE = <span class="number">4096</span>  <span class="comment"># 4048数据 + 16IV + 20 HMAC + 12</span>
    SQLITE_FILE_HEADER = <span class="built_in">bytes</span>(<span class="string">&quot;SQLite format 3&quot;</span>, encoding=<span class="string">&quot;ASCII&quot;</span>) + <span class="built_in">bytes</span>(<span class="number">1</span>)  <span class="comment"># SQLite 文件头</span>

    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:
        <span class="comment"># <span class="doctag">TODO:</span> 优化，考虑超大文件</span>
        blist = f.read()

    salt = blist[:<span class="number">16</span>]  <span class="comment"># 前16字节为盐</span>
    key = hashlib.pbkdf2_hmac(<span class="string">&quot;sha1&quot;</span>, password, salt, DEFAULT_ITER, KEY_SIZE)  <span class="comment"># 获得Key</span>

    page1 = blist[<span class="number">16</span>:DEFAULT_PAGESIZE]  <span class="comment"># 丢掉salt</span>

    mac_salt = <span class="built_in">bytes</span>([x ^ <span class="number">0x3a</span> <span class="keyword">for</span> x <span class="keyword">in</span> salt])
    mac_key = hashlib.pbkdf2_hmac(<span class="string">&quot;sha1&quot;</span>, key, mac_salt, <span class="number">2</span>, KEY_SIZE)

    hash_mac = hmac.new(mac_key, digestmod=<span class="string">&quot;sha1&quot;</span>)
    hash_mac.update(page1[:-<span class="number">32</span>])
    hash_mac.update(<span class="built_in">bytes</span>(ctypes.c_int(<span class="number">1</span>)))

    <span class="keyword">if</span> hash_mac.digest() != page1[-<span class="number">32</span>:-<span class="number">12</span>]:
        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;Wrong Password&quot;</span>)

    pages = [blist[i:i+DEFAULT_PAGESIZE] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(DEFAULT_PAGESIZE, <span class="built_in">len</span>(blist), DEFAULT_PAGESIZE)]
    pages.insert(<span class="number">0</span>, page1)  <span class="comment"># 把第一页补上</span>

    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span>.dec.db&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:
        f.write(SQLITE_FILE_HEADER)  <span class="comment"># 写入文件头</span>

        <span class="keyword">for</span> i <span class="keyword">in</span> pages:
            t = AES.new(key, AES.MODE_CBC, i[-<span class="number">48</span>:-<span class="number">32</span>])
            f.write(t.decrypt(i[:-<span class="number">48</span>]))
            f.write(i[-<span class="number">48</span>:])

<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    path = <span class="string">&quot;E:/wechat/documents/WeChat Files/wxid_44cdgh0tng3o41/Msg/Multi/MSG0.db&quot;</span>
    key = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;cannot tell u &quot;</span>) <span class="comment"># </span>

    decrypt_msg(path, key)</code></pre>

<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>后续内容就是要根据消息，进行相关的内容展示，方便搜索，方便查询，以及还有对应的表情包，语音，链接，图片，各种内容的展示。不单单只有文字。<br>这个后续的展示内容就留着以后再做吧。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.v2ex.com/t/466053">土办法导出 Mac 版微信聊天记录</a></li>
<li><a target="_blank" rel="noopener" href="https://daily.zhihu.com/story/8807166">iOS 微信的本地存储结构简析</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/luin/wechat-export">https://github.com/luin/wechat-export</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/BlueMatthew/WechatExporter">https://github.com/BlueMatthew/WechatExporter</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/forest0/wechat_history_export">https://github.com/forest0/wechat_history_export</a></li>
</ol>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">↑</a>
  </div>
</article>
<footer>
  &copy; 2023
  <span class="author">
    betta
  </span>
</footer>

    </div>
  </body>
</html>
