<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>火焰图分析 - Skywalker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=betta-cyber, game, betta, shokill>
  
    <meta name="description" content="betta">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="Skywalker" type="application/atom+xml">
  

  

  

  <!-- <link rel="stylesheet" href="../css/style.css"> -->
  
<link rel="stylesheet" href="/css/style.css">

  <script type='text/javascript' id='clustrmaps' src='//cdn.clustrmaps.com/map_v2.js?cl=ffffff&w=0&t=n&d=b9cDq33TdEsfGb_DpY--uB2pjskzQ8TK9LaE3yuIYzE&co=ffffff&cmo=ffffff&cmn=ffffff&ct=ffffff'></script>
<meta name="generator" content="Hexo 5.4.1"></head>

  <body>
    <div class="container">
      <header class="header">
  <!-- <div class="blog-title">
    <a href="/" class="logo">Skywalker</a>
    <div class="subtitle"></div>
  </div> -->
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link " >Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/blog" class="menu-item-link active" >Blog</a>
        </li>
      
        <li class="menu-item">
          <a href="/ebook" class="menu-item-link " >Ebook</a>
        </li>
      
        <li class="menu-item">
          <a href="/music" class="menu-item-link " >Music</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link " >About</a>
        </li>
      
    </ul>
  </nav>
</header>

<article class="post">
  <div class="post-title">
    <h1 class="article-title">火焰图分析</h1>
  </div>
  <div class="post-content">
    <p>关于火焰图的一些经验</p>
<h2 id="什么是Flame-Graph"><a href="#什么是Flame-Graph" class="headerlink" title="什么是Flame Graph?"></a>什么是Flame Graph?</h2><p>火焰图（Flame Graph）是由 Linux 性能优化大师 Brendan Gregg 发明的，和所有其他的 profiling 方法不同的是，火焰图以一个全局的视野来看待时间分布，它从底部往顶部，列出所有可能导致性能瓶颈的调用栈。</p>
<p>火焰图有以下特征（这里以 on-cpu 火焰图为例）：</p>
<p><img src="https://i.loli.net/2020/12/13/4l6qM9JW7ecCrHv.png" alt="job-4342741811-Lua-land-CPU-Flame-Graph.png"></p>
<ul>
<li>每一列代表一个调用栈，每一个格子代表一个函数</li>
<li>纵轴展示了栈的深度，按照调用关系从下到上排列。最顶上格子代表采样时，正在占用 cpu 的函数(或者是其他的特征)。</li>
<li>横轴的意义是指：火焰图将采集的多个调用栈信息，通过按字母横向排序的方式将众多信息聚合在一起。需要注意的是它并不代表时间。横轴格子的宽度代表其在采样中出现频率，所以一个格子的宽度越大，说明它是瓶颈原因的可能性就越大。(故这里的先后顺序与采样的顺序时间无关，只表示合起来的采样的总和)</li>
<li>火焰图格子的颜色是随机的暖色调，方便区分各个调用信息。</li>
<li>on-cpu 火焰图横轴是指 cpu 占用时间，off-cpu 火焰图横轴则代表阻塞时间。(这里的时间指代为相对时间)</li>
<li>采样可以是单线程、多线程、多进程甚至是多 host，进阶用法可以参考 <a target="_blank" rel="noopener" href="https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/index.html">systemtap-beginners-guide</a>和<a target="_blank" rel="noopener" href="https://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs">Blazing Performance with Flame Graphs</a></li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>这里按照openresty的xray产品提供的分析工具进行分类。不得不说xray是一款非常好用的产品。</p>
<p>还可以对生成的火焰图进行代码行级别和函数级别的区分。</p>
<p>以及对样本进行正向和反向的生成。下图就是上面例子的反向生成</p>
<p><img src="https://i.loli.net/2020/12/13/uiZ3Kwh4qFlNRWv.png" alt="job-4342741811-Lua-land-CPU-Flame-Graph-reversed.png"></p>
<p>xray里面提供了下面几种工具。不嫌麻烦的话其实 <a target="_blank" rel="noopener" href="https://github.com/openresty/openresty-systemtap-toolkit">openresty-systemtap-toolkit</a> 和 <a target="_blank" rel="noopener" href="https://github.com/openresty/stapxx">stapxx</a> 这两个工具集其实都可以实现。</p>
<ul>
<li>count-on-cpu-frames (count on cpu frames)</li>
<li>count-off-cpu-frames (count off cpu frames)</li>
<li>lj-c-on-cpu (C-land CPU Flame Graph)</li>
<li>lj-lua-on-cpu (Lua-land CPU Flame Graph)</li>
<li>lj-c-off-cpu (C-land off-CPU Flame Graph)</li>
<li>lj-lua-off-cpu (Lua-land off-CPU Flame Graph)</li>
<li>c-on-cpu (C-land CPU Flame Graph)</li>
<li>c-off-cpu (C-land off-CPU Flame Graph)</li>
<li>kernel-on-cpu (kernel-land on-CPU Flame Graph)</li>
<li>process-memory (Virtual Memory Usage Breakdown)</li>
<li>resty-memory (Application-Level Memory Usage Breakdown)</li>
<li>count-lj-newgco-frames (count LuaJIT new GC objcects frames)</li>
<li>lj-lua-newgco (LuaJIT GC Object Allocation Flame Graph)</li>
<li>glibc-chunks (Distributions of Memory Chunk Sizes in Glibc Allocator)</li>
<li>lj-gco-stat (Statistics for LuaJIT GC Objects)</li>
<li>count-lj-newthread-frames (count LuaJIT new thread frames)</li>
<li>lj-lua-newthread (LuaJIT Thread Objects Allocation Flame Graph)</li>
<li>lj-gco-ref (GC Object Reference Flame Graph)</li>
<li>count-c-memory-allocation-frames (count C Memory Allocation)</li>
<li>c-memory-allocation (C Memory Allocation Flame Graph)</li>
</ul>
<p>具体更多的信息可以参考工具集<a target="_blank" rel="noopener" href="https://github.com/openresty/stapxx">stapxx</a></p>
<h2 id="相关安装"><a href="#相关安装" class="headerlink" title="相关安装"></a>相关安装</h2><p>手动安装依赖的内核调试信息包</p>
<p>SystemTap需要内核信息，这样才能注入指令。此外，这些信息还能帮助SystemTap生成合适的检测代码。</p>
<p>这些必要的内核信息分别包括在特定内核版本所对应的-devel，-debuginfo和-debuginfo-common包中。对于“标准版”内核（指按照常规配置编译的内核），所需的-devel和-debuginfo等包命名为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel-debuginfo</span><br><span class="line">kernel-debuginfo-common</span><br><span class="line">kernel-devel</span><br></pre></td></tr></table></figure>
<p>要想确定当前系统的内核版本，敲入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p>举个例子，如果你想在i686环境下的2.6.18-53.el5内核上使用SystenTap，需要下载安装如下的RPM包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel-debuginfo-2.6.18-53.1.13.el5.i686.rpm</span><br><span class="line">kernel-debuginfo-common-2.6.18-53.1.13.el5.i686.rpm</span><br><span class="line">kernel-devel-2.6.18-53.1.13.el5.i686.rpm</span><br></pre></td></tr></table></figure>
<p>一旦手动下载了所依赖的包之后，以root权限运行下面的命令来安装它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --force -ivh package_names</span><br></pre></td></tr></table></figure>

<h3 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -v -e &#x27;probe vfs.read &#123;printf(&quot;read performed\n&quot;); exit()&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>如果出现相关输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pass 1: parsed user script and 45 library script(s) in 340usr/0sys/358real ms.</span><br><span class="line">Pass 2: analyzed script: 1 probe(s), 1 function(s), 0 embed(s), 0 global(s) in 290usr/260sys/568real ms.</span><br><span class="line">Pass 3: translated to C into &quot;/tmp/stapiArgLX/stap_e5886fa50499994e6a87aacdc43cd392_399.c&quot; in 490usr/430sys/938real ms.</span><br><span class="line">Pass 4: compiled C into &quot;stap_e5886fa50499994e6a87aacdc43cd392_399.ko&quot; in 3310usr/430sys/3714real ms.</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">read performed</span><br><span class="line">Pass 5: run completed in 10usr/40sys/73real ms.</span><br></pre></td></tr></table></figure>
<p>就表示安装完成</p>
<h2 id="火焰图分析技巧"><a href="#火焰图分析技巧" class="headerlink" title="火焰图分析技巧"></a>火焰图分析技巧</h2><ul>
<li>纵轴代表调用栈的深度（栈桢数），用于表示函数间调用关系：下面的函数是上面函数的父函数。</li>
<li>横轴代表调用频次，一个格子的宽度越大，越说明其可能是瓶颈原因。</li>
<li>不同类型火焰图适合优化的场景不同，比如 on-cpu 火焰图适合分析 cpu 占用高的问题函数，off-cpu 火焰图适合解决阻塞和锁抢占问题。</li>
<li>无意义的事情：横向先后顺序是为了聚合，跟函数间依赖或调用关系无关；火焰图各种颜色是为方便区分，本身不具有特殊含义</li>
<li>多练习：进行性能优化有意识的使用火焰图的方式进行性能调优（如果时间充裕）</li>
</ul>
<h2 id="使用-perf-或者-systemtap-的方式采集数据，会对后台服务有性能影响吗？"><a href="#使用-perf-或者-systemtap-的方式采集数据，会对后台服务有性能影响吗？" class="headerlink" title="使用 perf 或者 systemtap 的方式采集数据，会对后台服务有性能影响吗？"></a>使用 perf 或者 systemtap 的方式采集数据，会对后台服务有性能影响吗？</h2><p>有，但是很小，可以基本忽略不计。</p>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">↑</a>
  </div>
</article>
<footer>
  &copy; 2023
  <span class="author">
    betta
  </span>
</footer>

    </div>
  </body>
</html>
