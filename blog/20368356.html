<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>Rust 生命周期 - Skywalker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=betta-cyber, game, betta, shokill>
  
    <meta name="description" content="betta">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="Skywalker" type="application/atom+xml">
  

  
  <!-- <link rel="stylesheet" href="../css/style.css"> -->
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.1"></head>

  <body>
    <div class="container">
      <header class="header">
  <!-- <div class="blog-title">
    <a href="/" class="logo">Skywalker</a>
    <div class="subtitle"></div>
  </div> -->
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link " >Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/blog" class="menu-item-link active" >Blog</a>
        </li>
      
        <li class="menu-item">
          <a href="/ebook" class="menu-item-link " >Ebook</a>
        </li>
      
        <li class="menu-item">
          <a href="/music" class="menu-item-link " >Music</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link " >About</a>
        </li>
      
    </ul>
  </nav>
</header>

<article class="post">
  <div class="post-title">
    <h1 class="article-title">Rust 生命周期</h1>
  </div>
  <div class="post-content">
    <p>学习生命周期参数的意义是，避免出现悬垂指针。</p>
<p>在全球70%的安全漏洞里面，悬垂指针可能占50%，所以避免出现悬垂指针是一个很重要的安全保障。</p>
<h3 id="悬垂指针的成因"><a href="#悬垂指针的成因" class="headerlink" title="悬垂指针的成因"></a>悬垂指针的成因</h3><p>在许多编程语言中（比如C），显示地从内存中删除一个对象或者返回时通过销毁栈帧，并不会改变相关的指针的值。该指针仍旧指向内存中相同的位置，即使引用已经被删除，现在可能已经挪作他用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   char *dp = NULL;</span><br><span class="line">   /* ... */</span><br><span class="line">   &#123;</span><br><span class="line">       char c;</span><br><span class="line">       dp = &amp;c;</span><br><span class="line">   &#125; /* c falls out of scope */</span><br><span class="line">   /* dp is now a dangling pointer */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果操作系统能够侦测运行时的指向空指针的引用，一个方案是在内部快消失之前给dp赋为0（NULL）。另一个方案是保证dp在没有被初始化之前不再被使用。</p>
<p>另一个常见原因是混用 malloc() 和 free()：当一个指针指向的内存被释放后就会变成悬垂指针。正如上个例子，可以避免这个问题的一种方法是在释放它的引用后把指针重置为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    char *dp = malloc(A_CONST);</span><br><span class="line">    /* ... */</span><br><span class="line">    free(dp);         /* dp now becomes a dangling pointer */</span><br><span class="line">    dp = NULL;        /* dp is no longer dangling */</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个很常见的失误是返回一个栈分配的局部变量：一旦调用的函数返回了，分配给这些变量的空间被回收，此时它们拥有的是“垃圾值”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *func(void)</span><br><span class="line">&#123;</span><br><span class="line">    int num = 1234;</span><br><span class="line">    /* ... */</span><br><span class="line">    return &amp;num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 func 后，尝试从该指针暂时能读取到正确的值（1234），但是再次调用函数后将会重写栈为 num 分配的的值，再从该指针读取的值就不正确了。如果必须要返回一个指向 num 的指针，num 的作用域必须大于这个函数——它也许被声明为 static。</p>
<h3 id="什么是生命周期"><a href="#什么是生命周期" class="headerlink" title="什么是生命周期"></a>什么是生命周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let a;                // -------------+-- a start</span><br><span class="line">  &#123;                     //              |</span><br><span class="line">    let b = 5;          // -+-- b start |</span><br><span class="line">    a = &amp;b;             //  |           |</span><br><span class="line">  &#125;                     // -+-- b over  |</span><br><span class="line">  println!(&quot;a: &#123;&#125;&quot;, a); //              |</span><br><span class="line">&#125;                       // -------------+-- a over</span><br></pre></td></tr></table></figure>

<p>上面第 5 行代码把变量b 借给了变量a，所以 a 是借用方，b 是出借方。可以发现变量a（借用方）的生命周期比变量b（出借方）的生命周期长，于是这样做违背了 rust 的借用规则（借用方的生命周期不能比出借方的生命周期还要长）。因为当 b 在生命周期结束时，a 还是保持了对 b 的借用，就会导致 a 所指向的那块内存空间已经被释放了，那么变量 a 就会是一个悬垂引用。</p>
<p>对于一个参数和返回值都包含引用的函数而言，该函数的参数是出借方，函数返回值所绑定到的那个变量就是借用方。所以这种函数也需要满足借用规则（借用方的生命周期不能比出借方的生命周期还要长）。那么就需要对函数返回值的生命周期进行标注，告知编译器函数返回值的生命周期信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn max_num(x: &amp;i32, y: &amp;i32) -&gt; &amp;i32 &#123;</span><br><span class="line">  if x &gt; y &#123;</span><br><span class="line">    &amp;x</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &amp;y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">  let x = 1;                // -------------+-- x start</span><br><span class="line">  let max;                  // -------------+-- max start</span><br><span class="line">  &#123;                         //              |</span><br><span class="line">    let y = 8;              // -------------+-- y start</span><br><span class="line">    max = max_num(&amp;x, &amp;y);  //              |</span><br><span class="line">  &#125;                         // -------------+-- y over</span><br><span class="line">  println!(&quot;max: &#123;&#125;&quot;, max); //              |</span><br><span class="line">&#125;                           // -------------+-- max, x over</span><br></pre></td></tr></table></figure>

<p>由于缺少生命周期参数，编译器不知道 max_num 函数返回的引用生命周期是什么，所以运行报错：</p>
<p>函数的生命周期参数声明在函数名后的尖括号 &lt;&gt; 里，然后每个参数名跟在一个单引号’ 后面，多个参数用逗号隔开。如果在参数和返回值的地方需要使用生命周期进行标注时，只需要在 &amp; 符号后面加上一个单引号’ 和之前声明的参数名即可。生命周期参数名可以是任意合法的名称。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn max_num&lt;&#x27;a&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 &#123;</span><br><span class="line">  if x &gt; y &#123;</span><br><span class="line">    &amp;x</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &amp;y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">  let x = 1;                // -------------+-- x start</span><br><span class="line">  let max;                  // -------------+-- max start</span><br><span class="line">  &#123;                         //              |</span><br><span class="line">    let y = 8;              // -------------+-- y start</span><br><span class="line">    max = max_num(&amp;x, &amp;y);  //              |</span><br><span class="line">  &#125;                         // -------------+-- y over</span><br><span class="line">  println!(&quot;max: &#123;&#125;&quot;, max); //              |</span><br><span class="line">&#125;                           // -------------+-- max, x over</span><br></pre></td></tr></table></figure>

<p>上面代码对函数 max_num 的参数和返回值的生命周期进行了标注，用于告诉编译器函数参数和函数返回值的生命周期一样长。在第 13 行代码对 max_num 进行调用时，编译器会把变量 x 的生命周期和变量 y 的生命周期与 max_num 函数的生命周期参数’a 建立关联。这里值得注意的是，变量 x 和变量 y 的生命周期长短其实是不一样的，那么关联到 max_num 函数的生命周期参数’a 的长度是多少呢？实际上编译器会取变量 x 的生命周期和变量 y 的生命周期重叠的部分，也就是取最短的那个变量的生命周期与’a 建立关联。这里最短的生命周期是变量 y，所以’a 关联的生命周期就是变量 y 的生命周期。</p>
<p>运行上面代码，会有报错信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `y` does not live long enough</span><br><span class="line">  --&gt; src/main.rs:13:27</span><br><span class="line">   |</span><br><span class="line">13 |         max = max_num(&amp;x, &amp;y);</span><br><span class="line">   |                           ^^ borrowed value does not live long enough</span><br><span class="line">14 |     &#125;</span><br><span class="line">   |     - `y` dropped here while still borrowed</span><br><span class="line">15 |     println!(&quot;max: &#123;&#125;&quot;, max);</span><br><span class="line">   |                         --- borrow later used here</span><br></pre></td></tr></table></figure>

<p>报错信息说变量 y 的生命周期不够长，当 y 的生命周期结束后，仍然被借用。</p>
<p>我们仔细观察发现 max_num 函数返回值所绑定到的那个变量 max（借用方）的生命周期是从第 10 行代码到第 16 行代码，而 max_num 函数的返回值（出借方）的生命周期是’a，’a 的生命周期又是变量 x 的生命周期和变量 y 的生命周期中最短的那个，也就是变量 y 的生命周期。变量 y 的生命周期是代码的第 12 行到第 14 行。所以这里不满足借用规则（借用方的生命周期不能比出借方的生命周期还要长）。也就是为什么编译器会说变量 y 的生命周期不够长的原因了。函数的生命周期参数并不会改变生命周期的长短，只是用于编译来判断是否满足借用规则。</p>
<p>将代码做如下调整，使其变量 max 的生命周期小于变量 y 的生命周期，编译器就可以正常通过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn max_num&lt;&#x27;a&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 &#123;</span><br><span class="line">  if x &gt; y &#123;</span><br><span class="line">    &amp;x</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &amp;y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">  let x = 1;                  // -------------+-- x start</span><br><span class="line">  let y = 8;                  // -------------+-- y start</span><br><span class="line">  let max = max_num(&amp;x, &amp;y);  // -------------+-- max start</span><br><span class="line">  println!(&quot;max: &#123;&#125;&quot;, max);   //              |</span><br><span class="line">&#125;                             // -------------+-- max, y, x over</span><br></pre></td></tr></table></figure>

<p>函数存在多个生命周期参数时，需要标注各个参数之间的关系。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn max_num&lt;&#x27;a, &#x27;b: &#x27;a&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;b i32) -&gt; &amp;&#x27;a i32 &#123;</span><br><span class="line">  if x &gt; y &#123;</span><br><span class="line">    &amp;x</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &amp;y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">  let x = 1;                  // -------------+-- x start</span><br><span class="line">  let y = 8;                  // -------------+-- y start</span><br><span class="line">  let max = max_num(&amp;x, &amp;y);  // -------------+-- max start</span><br><span class="line">  println!(&quot;max: &#123;&#125;&quot;, max);   //              |</span><br><span class="line">&#125;                             // -------------+-- max, y, x over</span><br></pre></td></tr></table></figure>

<p>上面代码使用’b: ‘a 来标注’a 与’b 之间的生命周期关系，它表示’a 的生命周期不能超过’b，即函数返回值的生命周期’a（借用方）不能超过’b&#96;&#96;（出借方），‘a 也不会超过‘a&#96;（出借方）。</p>
<h3 id="结构体中的生命周期参数"><a href="#结构体中的生命周期参数" class="headerlink" title="结构体中的生命周期参数"></a>结构体中的生命周期参数</h3><p>一个包含引用成员的结构体，必须保证结构体本身的生命周期不能超过任何一个引用成员的生命周期。否则就会出现成员已经被销毁之后，结构体还保持对那个成员的引用就会产生悬垂引用。所以这依旧是 rust 的借用规则即借用方（结构体本身）的生命周期不能比出借方（结构体中的引用成员）的生命周期还要长。因此就需要在声明结构体的同时也声明生命周期参数，同时对结构体的引用成员进行生命周期参数标注。</p>
<p>结构体生命周期参数声明在结构体名称后的尖括号 &lt;&gt; 里，每个参数名跟在一个单引号’ 后面，多个参数用逗号隔开。在进行标注时，只需要在引用成员的 &amp; 符号后面加上一个单引号’ 和之前声明的参数名即可。生命周期参数名可以是任意合法的名称。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Foo&lt;&#x27;a&gt; &#123;</span><br><span class="line">    v: &amp;&#x27;a i32</span><br><span class="line">&#125;&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="静态生命周期参数"><a href="#静态生命周期参数" class="headerlink" title="静态生命周期参数"></a>静态生命周期参数</h3><p>有一个特殊的生命周期参数叫 static，它的生命周期是整个应用程序。跟其他生命周期参数不同的是，它是表示一个具体的生命周期长度，而不是泛指。static 生命周期的变量存储在静态段中。</p>
<p>所有的字符串字面值都是 ‘static 生命周期，例如：’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s: &amp;&#x27;static str = &quot;s is a static lifetime.&quot;;&#x27;</span><br></pre></td></tr></table></figure>

<p>上面代码中的生命周期参数可以省略，就变成如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s: &amp;str = &quot;s is a static lifetime.&quot;;</span><br></pre></td></tr></table></figure>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">↑</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    betta
  </span>
</footer>

    </div>
  </body>
</html>
