<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>rust和openresty的性能问题 - hang on to your dreams</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=blog, game, betta>
  
    <meta name="description" content="betta">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="hang on to your dreams" type="application/atom+xml">
  

  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

  <body>
    <div class="container">
      <header class="header">
  <!-- <div class="blog-title">
    <a href="/" class="logo">hang on to your dreams</a>
    <div class="subtitle"></div>
  </div> -->
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
    </ul>
  </nav>
</header>

<article class="post">
  <div class="post-title">
    <h1 class="article-title">rust和openresty的性能问题</h1>
  </div>
  <div class="post-content">
    <p>关于rust和openresty的一些问题</p>
<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>最近要入职斗鱼了，然后这边准备入职之后负责一个斗鱼的安全网关和WAF相关的一些事情。考虑到斗鱼这边使用openresty来实现WAF功能。我这边之前又在学习RUST，所以我来做一个测试，想测试一下用RUST来做一个安全网关的工作。看看能不能又一点的效果。</p>
<p>之前都是在用apache自带的ab做压力测试。后面考虑到性能测试的准确性，我于是用了wrk这个工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;wg&#x2F;wrk</span><br><span class="line">cd wrk</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>编译之后在下面生成wrk的文件，可以通过一些参数测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;wrk -t 4 -c 100 -d 10s --latency http:&#x2F;&#x2F;10.1.78.178:3001</span><br></pre></td></tr></table></figure>

<p>我这边用rust的hyper做了一个gateway的一个功能，主要是吧流量代理到0.0.0.0:8080上面，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#![deny(warnings)]</span><br><span class="line"></span><br><span class="line">use hyper::service::&#123;make_service_fn, service_fn&#125;;</span><br><span class="line">use hyper::&#123;Client, Error, Server&#125;;</span><br><span class="line">use std::net::SocketAddr;</span><br><span class="line"></span><br><span class="line">#[tokio::main]</span><br><span class="line">async fn main() &#123;</span><br><span class="line">    pretty_env_logger::init();</span><br><span class="line"></span><br><span class="line">    let in_addr &#x3D; ([0, 0, 0, 0], 3001).into();</span><br><span class="line">    let out_addr: SocketAddr &#x3D; ([0, 0, 0, 0], 8080).into();</span><br><span class="line"></span><br><span class="line">    let client_main &#x3D; Client::new();</span><br><span class="line"></span><br><span class="line">    let out_addr_clone &#x3D; out_addr.clone();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The closure inside &#96;make_service_fn&#96; is run for each connection,</span><br><span class="line">    &#x2F;&#x2F; creating a &#39;service&#39; to handle requests for that specific connection.</span><br><span class="line">    let make_service &#x3D; make_service_fn(move |_| &#123;</span><br><span class="line">        let client &#x3D; client_main.clone();</span><br><span class="line"></span><br><span class="line">        async move &#123;</span><br><span class="line">            &#x2F;&#x2F; This is the &#96;Service&#96; that will handle the connection.</span><br><span class="line">            &#x2F;&#x2F; &#96;service_fn&#96; is a helper to convert a function that</span><br><span class="line">            &#x2F;&#x2F; returns a Response into a &#96;Service&#96;.</span><br><span class="line">            Ok::&lt;_, Error&gt;(service_fn(move |mut req| &#123;</span><br><span class="line">                let uri_string &#x3D; format!(</span><br><span class="line">                    &quot;http:&#x2F;&#x2F;&#123;&#125;&#123;&#125;&quot;,</span><br><span class="line">                    out_addr_clone,</span><br><span class="line">                    req.uri().path_and_query().map(|x| x.as_str()).unwrap_or(&quot;&quot;)</span><br><span class="line">                );</span><br><span class="line">                let uri &#x3D; uri_string.parse().unwrap();</span><br><span class="line">                *req.uri_mut() &#x3D; uri;</span><br><span class="line">                client.request(req)</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let server &#x3D; Server::bind(&amp;in_addr).serve(make_service);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Listening on http:&#x2F;&#x2F;&#123;&#125;&quot;, in_addr);</span><br><span class="line">    println!(&quot;Proxying on http:&#x2F;&#x2F;&#123;&#125;&quot;, out_addr);</span><br><span class="line"></span><br><span class="line">    if let Err(e) &#x3D; server.await &#123;</span><br><span class="line">        eprintln!(&quot;server error: &#123;&#125;&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我用openresty的官方最新下载包，<a href="https://openresty.org/cn/getting-started.html" target="_blank" rel="noopener">安装编译</a>。然后编写相关的openresty的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line">error_log logs&#x2F;error.log;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8081;</span><br><span class="line">        location &#x2F;hello &#123;</span><br><span class="line">            default_type text&#x2F;html;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                ngx.say(&quot;&lt;p&gt;hello, world&lt;&#x2F;p&gt;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对流量进行了proxy_pass的代理到8080端口，然后我在8080后面用tornado启动了一个http服务。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>rust-hyper写的测试结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;wrk -t 4 -c 100 -d 10s --latency http:&#x2F;&#x2F;10.1.78.178:3001</span><br><span class="line">Running 10s test @ http:&#x2F;&#x2F;10.1.78.178:3001</span><br><span class="line">  4 threads and 100 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +&#x2F;- Stdev</span><br><span class="line">    Latency    48.49ms    3.14ms  82.11ms   87.34%</span><br><span class="line">    Req&#x2F;Sec   517.28     53.08   696.00     82.50%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   47.98ms</span><br><span class="line">     75%   49.70ms</span><br><span class="line">     90%   51.35ms</span><br><span class="line">     99%   62.28ms</span><br><span class="line">  20600 requests in 10.03s, 5.01MB read</span><br><span class="line">Requests&#x2F;sec:   2053.78</span><br><span class="line">Transfer&#x2F;sec:    511.44KB</span><br></pre></td></tr></table></figure>

<p>openresty的测试结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;wrk -t 4 -c 100 -d 10s --latency http:&#x2F;&#x2F;10.1.78.178:8081</span><br><span class="line">Running 10s test @ http:&#x2F;&#x2F;10.1.78.178:8081</span><br><span class="line">  4 threads and 100 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +&#x2F;- Stdev</span><br><span class="line">    Latency    60.43ms    3.96ms  74.39ms   85.46%</span><br><span class="line">    Req&#x2F;Sec   414.72    103.06   505.00     75.00%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   59.69ms</span><br><span class="line">     75%   61.90ms</span><br><span class="line">     90%   65.07ms</span><br><span class="line">     99%   71.96ms</span><br><span class="line">  16525 requests in 10.03s, 4.38MB read</span><br><span class="line">Requests&#x2F;sec:   1648.06</span><br><span class="line">Transfer&#x2F;sec:    447.37KB</span><br></pre></td></tr></table></figure>

<p>可以看出rust的性能还是比openresty要强的，这里还用的不是actix-web这个性能怪兽。然后在这里主要还是lua的拓展性比较强，但是我个人觉得其实rust在这块其实做的也不错。我会尝试用rust取构建一个安全网关。</p>

  </div>
  <div id="comments"></div>
  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2021
  <span class="author">
    betta-cyber
  </span>
</footer>

<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script>
<script>
const gitment = new Gitment({
  id: 'Fri Mar 27 2020 15:34:00 GMT+0000',
  owner: 'betta-cyber',
  repo: 'betta-cyber.github.io',
  oauth: {
    client_id: 'e32a2371d055a4a6872f',
    client_secret: '8b5c050a8fffd9ed254c421080cf55d7ae55f266',
  },
})

gitment.render('comments')
</script>

    </div>
  </body>
</html>
